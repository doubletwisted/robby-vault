<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Robby — CA: Cyclic</title>
  <style>
    html,body{height:100%;margin:0;background:#05060a;overflow:hidden}
    canvas{width:100%;height:100%;display:block}
    .hud{position:fixed;left:14px;top:14px;color:#e6e6e6;font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:12px;backdrop-filter: blur(6px);
    }
    .hud b{color:#8df}
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">
  <div><b>CA: CYCLIC</b> — waves & spirals</div>
  <div>Keys: <b>R</b> reseed · <b>Space</b> pause · <b>[</b>/<b>]</b> threshold</div>
</div>
<script>
  const c = document.getElementById('c');
  const ctx = c.getContext('2d', {alpha:false});

  let W=0,H=0,scale=2,gw=0,gh=0;
  let a,b;
  let paused=false;

  const states = 14;      // number of colors
  let threshold = 3;     // neighbor count needed to advance

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio||1);
    W = Math.floor(innerWidth*dpr);
    H = Math.floor(innerHeight*dpr);
    c.width=W; c.height=H;
    const targetCells = 300;
    scale = Math.max(2, Math.floor(Math.min(W,H)/targetCells));
    gw = Math.floor(W/scale);
    gh = Math.floor(H/scale);
    a = new Uint8Array(gw*gh);
    b = new Uint8Array(gw*gh);
    seed();
  }

  function idx(x,y){
    x = (x+gw)%gw;
    y = (y+gh)%gh;
    return x+y*gw;
  }

  function seed(){
    for(let i=0;i<a.length;i++) a[i] = (Math.random()*states)|0;
  }

  function step(){
    for(let y=0;y<gh;y++){
      for(let x=0;x<gw;x++){
        const i=x+y*gw;
        const v=a[i];
        const next=(v+1)%states;
        let hit=0;
        // Moore neighborhood
        for(let oy=-1;oy<=1;oy++){
          for(let ox=-1;ox<=1;ox++){
            if(!ox&&!oy) continue;
            if(a[idx(x+ox,y+oy)]===next) hit++;
          }
        }
        b[i] = (hit>=threshold) ? next : v;
      }
    }
    const t=a; a=b; b=t;
  }

  function color(v, t){
    const hue = (v/states)*320 + 20 + 30*Math.sin(t*0.2);
    const sat = 85;
    const lig = 55 + 10*Math.sin(t*0.12 + v*0.6);
    return `hsl(${hue%360}, ${sat}%, ${lig}%)`;
  }

  function draw(){
    requestAnimationFrame(draw);
    if(!paused) step();

    const t = performance.now()*0.001;
    // draw cells
    for(let y=0;y<gh;y++){
      for(let x=0;x<gw;x++){
        const v=a[x+y*gw];
        ctx.fillStyle = color(v,t);
        ctx.fillRect(x*scale,y*scale,scale,scale);
      }
    }

    // soft contrast / vignette
    ctx.fillStyle='rgba(0,0,0,0.06)';
    ctx.fillRect(0,0,W,H);
  }

  addEventListener('resize', resize);
  addEventListener('keydown', (e)=>{
    if(e.key===' '){ paused=!paused; }
    if(e.key==='r' || e.key==='R'){ seed(); }
    if(e.key==='['){ threshold = Math.max(1, threshold-1); }
    if(e.key===']'){ threshold = Math.min(8, threshold+1); }
  });

  resize();
  draw();
</script>
</body>
</html>
