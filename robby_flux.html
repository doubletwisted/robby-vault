<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Glass Flux - Robby Freestyle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300&display=swap');
        body { margin: 0; overflow: hidden; background: #010205; font-family: 'Space Grotesk', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed;
            top: 40px;
            right: 40px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.6em;
            text-transform: uppercase;
            font-size: 8px;
            pointer-events: none;
            text-align: right;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding-right: 20px;
        }
    </style>
</head>
<body>
    <div id="hud">
        Experiment 18 // The Glass Flux<br>
        IOR: 1.45 (Crystalline)<br>
        Dispersion: ENABLED
    </div>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2', { antialias: true });

        const vs = `#version 300 es
            void main() {
                gl_Position = vec4(vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) * 2.0 - 1.0, 0.0, 1.0);
            }
        `;

        const fs = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        uniform vec2 u_res;
        uniform float u_time;
        uniform vec2 u_mouse;

        mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }

        float sdBox(vec3 p, vec3 b) {
            vec3 q = abs(p) - b;
            return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        float map(vec3 p) {
            p.xz *= rot(u_time * 0.2);
            p.yz *= rot(u_time * 0.1);
            float d = sdBox(p, vec3(1.0)) - 0.2; // Rounded box
            
            // Subtracting some internal structure
            float s = 0.5;
            vec3 q = mod(p + s*0.5, s) - s*0.5;
            d = max(d, -(length(q) - 0.22));
            
            return d * 0.7;
        }

        vec3 getNormal(vec3 p) {
            vec2 e = vec2(0.001, 0);
            return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_res) / min(u_res.x, u_res.y);
            vec2 m = (u_mouse / u_res) * 2.0 - 1.0;
            
            vec3 ro = vec3(0, 0, -5);
            vec3 rd = normalize(vec3(uv, 2.5));
            rd.xz *= rot(m.x * 0.2);
            rd.yz *= rot(-m.y * 0.2);

            vec3 col = vec3(0.0);
            float t = 0.0;
            
            // First pass: Outside
            for(int i=0; i<80; i++) {
                float d = map(ro + rd * t);
                if(abs(d) < 0.001 || t > 10.0) break;
                t += d;
            }

            if(t < 10.0) {
                vec3 p = ro + rd * t;
                vec3 n = getNormal(p);
                vec3 ref = reflect(rd, n);
                
                // Chromatic Aberration in Refraction
                vec3 refrR = refract(rd, n, 1.0/1.45);
                vec3 refrG = refract(rd, n, 1.0/1.48);
                vec3 refrB = refract(rd, n, 1.0/1.51);
                
                // Fake environment background (deep space)
                float sky = pow(max(0.0, dot(ref, vec3(0,1,0))), 8.0);
                
                col.r = texture(u_res.x > 0.0 ? vec2(0.0) : vec2(0.0), refrR.xy).r + sky; // Placeholder-ish logic
                col.g = sky * 0.5;
                col.b = sky * 0.8;
                
                // Fresnel
                float fres = pow(1.0 + dot(rd, n), 5.0);
                col += fres * vec3(0.8, 0.9, 1.0) * 0.5;
                
                // Internal glow
                float glow = sin(p.y * 10.0 - u_time * 2.0) * 0.5 + 0.5;
                col += vec3(0.0, 0.5, 1.0) * glow * 0.2;
            } else {
                col = vec3(0.01, 0.015, 0.02) * (1.0 - length(uv));
            }

            fragColor = vec4(pow(col, vec3(0.9)), 1.0);
        }
        `;

        function createShader(gl, type, source) {
            const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s);
            return s;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);

        const uRes = gl.getUniformLocation(program, 'u_res');
        const uTime = gl.getUniformLocation(program, 'u_time');
        const uMouse = gl.getUniformLocation(program, 'u_mouse');

        let mx = 0, my = 0;
        window.addEventListener('mousemove', e => { mx = e.clientX; my = window.innerHeight - e.clientY; });
        window.addEventListener('touchmove', e => { mx = e.touches[0].clientX; my = window.innerHeight - e.touches[0].clientY; });

        function render(t) {
            const w = window.innerWidth, h = window.innerHeight;
            if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
            gl.viewport(0, 0, w, h);
            gl.useProgram(program);
            gl.uniform2f(uRes, w, h);
            gl.uniform1f(uTime, t * 0.001);
            gl.uniform2f(uMouse, mx, my);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
