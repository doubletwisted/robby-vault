<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Robby — XOR_CELL</title>
  <style>
    body{margin:0;overflow:hidden;background:#000;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    canvas{width:100vw;height:100vh;display:block}
    #hud{position:fixed;left:22px;top:22px;color:rgba(255,255,255,.35);letter-spacing:.35em;text-transform:uppercase;font-size:10px;pointer-events:none;border-left:1px solid rgba(255,255,255,.18);padding-left:14px}
  </style>
</head>
<body>
  <div id="gl2warn" style="display:none;position:fixed;inset:0;background:#000;color:#e6e6e6;z-index:9999;padding:20px;font:14px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;">
    <div style="max-width:820px">
      <div style="color:#ff4d4d;letter-spacing:.2em;text-transform:uppercase;font-size:12px">WebGL2 required</div>
      <h1 style="margin:10px 0 8px 0;font-size:18px">XOR_CELL needs WebGL2.</h1>
      <div style="opacity:.8">Try Chrome/Edge on desktop, or update iOS.</div>
    </div>
  </div>

  <div id="hud">XOR_CELL // life texture
  <br/>scroll = density · tap = seed</div>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('webgl2', { antialias: true });
    if(!gl){ document.getElementById('gl2warn').style.display='block'; throw new Error('WebGL2 missing'); }

    const vs = `#version 300 es
    void main(){ gl_Position = vec4(vec2((gl_VertexID<<1)&2, gl_VertexID&2)*2.0-1.0, 0, 1); }`;

    const fs = `#version 300 es
    precision highp float;
    out vec4 fragColor;
    uniform vec2 u_res;
    uniform float u_time;
    uniform vec2 u_mouse;
    uniform float u_density;
    uniform float u_seed;

    float hash(vec2 p){
      p = fract(p*vec2(123.34,456.21));
      p += dot(p,p+45.32);
      return fract(p.x*p.y);
    }

    vec3 pal(float t){
      vec3 a=vec3(0.06,0.06,0.07);
      vec3 b=vec3(0.55,0.45,0.35);
      vec3 c=vec3(1.0,1.0,1.0);
      vec3 d=vec3(0.00,0.18,0.33);
      return a + b*cos(6.28318*(c*t + d));
    }

    // fake CA: evolve a discrete field from hashed neighbors (temporal XOR-ish)
    float cell(vec2 id, float t){
      float a = hash(id + floor(t));
      float b = hash(id + vec2(1,0) + floor(t*1.13));
      float c = hash(id + vec2(0,1) + floor(t*0.91));
      float d = hash(id + vec2(1,1) + floor(t*1.07));
      float s = a + b + c + d;
      float q = fract(s * 1.618);
      // quantize
      return step(0.55, q);
    }

    void main(){
      vec2 uv = gl_FragCoord.xy / u_res;
      vec2 p = (gl_FragCoord.xy*2.0 - u_res) / min(u_res.x,u_res.y);
      vec2 m = (u_mouse/u_res)*2.0-1.0;
      m.x *= u_res.x/u_res.y;

      float t = u_time;

      float dens = mix(35.0, 120.0, u_density);
      vec2 g = uv * vec2(dens, dens * (u_res.y/u_res.x));
      vec2 id = floor(g);
      vec2 f = fract(g)-0.5;

      // neighborhood-ish field
      float c0 = cell(id, t*0.8 + u_seed*3.0);
      float c1 = cell(id+vec2(1,0), t*0.8 + u_seed*3.0);
      float c2 = cell(id+vec2(0,1), t*0.8 + u_seed*3.0);
      float c3 = cell(id-vec2(1,0), t*0.8 + u_seed*3.0);

      float n = c0 + c1 + c2 + c3;
      float v = smoothstep(1.2, 3.0, n);

      // halo / lens polish
      float r = length(p);
      float ring = exp(-pow(abs(r-0.68),2.0)*40.0);
      float core = exp(-r*r*2.5);

      // mouse seed injection
      float md = length(p - m*0.6);
      float inject = exp(-md*md*8.0) * (0.7 + 0.3*sin(t*4.0));

      float ink = v + 0.65*inject;

      // micro-structure
      float spark = smoothstep(0.22, 0.0, length(f)) * c0;

      vec3 col = pal(ink*0.55 + hash(id)*0.25 + t*0.03);
      col *= mix(vec3(0.10,0.75,0.85), vec3(1.15,0.62,0.20), core);

      col *= 0.25 + 1.25*ink;
      col += ring*vec3(0.10,0.75,0.85)*0.35;
      col += core*vec3(1.0,0.55,0.20)*0.55;
      col += spark*vec3(1.0,0.9,0.7)*0.35;

      // grain
      col += (hash(uv*vec2(900.0,600.0)+fract(t)*17.0)-0.5)*0.05;

      col = col/(col+vec3(1.0));
      col = pow(col, vec3(0.92));

      fragColor = vec4(col,1.0);
    }`;

    function sh(type, src){
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        const err = gl.getShaderInfoLog(s) || 'compile error';
        console.error(err);
        alert(err);
        throw new Error(err);
      }
      return s;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
      const err = gl.getProgramInfoLog(prog) || 'link error';
      console.error(err);
      alert(err);
      throw new Error(err);
    }

    const uRes = gl.getUniformLocation(prog, 'u_res');
    const uTime = gl.getUniformLocation(prog, 'u_time');
    const uMouse = gl.getUniformLocation(prog, 'u_mouse');
    const uDen = gl.getUniformLocation(prog, 'u_density');
    const uSeed = gl.getUniformLocation(prog, 'u_seed');

    let mx=0,my=0;
    let density = 0.45;
    let seed = 0.0;

    function setMouse(e){
      mx = e.clientX;
      my = window.innerHeight - e.clientY;
    }
    addEventListener('mousemove', setMouse);
    addEventListener('touchmove', (e)=>{ if(e.touches && e.touches[0]) setMouse(e.touches[0]); }, {passive:true});

    addEventListener('wheel', (e)=>{ density = Math.min(1, Math.max(0, density + e.deltaY*-0.0006)); }, {passive:true});
    addEventListener('pointerdown', ()=>{ seed = (seed + 0.37) % 1000.0; });

    function resize(){
      const dpr = Math.min(2, devicePixelRatio||1);
      canvas.width = Math.floor(innerWidth*dpr);
      canvas.height = Math.floor(innerHeight*dpr);
      gl.viewport(0,0,canvas.width,canvas.height);
    }
    addEventListener('resize', resize);
    resize();

    function tick(t){
      t *= 0.001;
      gl.useProgram(prog);
      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.uniform1f(uTime, t);
      gl.uniform2f(uMouse, mx, my);
      gl.uniform1f(uDen, density);
      gl.uniform1f(uSeed, seed);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
