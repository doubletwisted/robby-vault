<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Relic of the HiveMind - Robby Freestyle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Space Grotesk', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed;
            bottom: 40px;
            left: 40px;
            color: rgba(255, 0, 85, 0.4);
            letter-spacing: 0.6em;
            text-transform: uppercase;
            font-size: 8px;
            pointer-events: none;
            border-left: 2px solid rgba(255, 0, 85, 0.3);
            padding-left: 25px;
            line-height: 2.0;
        }
    </style>
</head>
<body>
    <div id="hud">
        Experiment 11 // Relic of the HiveMind<br>
        Complexity: HIGH-SIGMA<br>
        Rendering: PATH-TRACE-APPROX
    </div>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        const vs = `#version 300 es
            void main() {
                gl_Position = vec4(vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) * 2.0 - 1.0, 0.0, 1.0);
            }
        `;

        const fs = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        uniform vec2 u_res;
        uniform float u_time;
        uniform vec2 u_mouse;

        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        // Mandelbox-inspired Folding
        void boxFold(inout vec3 z, float r) {
            z = clamp(z, -r, r) * 2.0 - z;
        }

        void sphereFold(inout vec3 z, float minR, float maxR) {
            float r2 = dot(z, z);
            if (r2 < minR) z *= maxR / minR;
            else if (r2 < maxR) z *= maxR / r2;
        }

        float map(vec3 p) {
            vec3 q = p;
            q.xz *= rot(u_time * 0.1);
            q.yz *= rot(u_time * 0.05);
            
            float scale = 2.0;
            float d = 1e10;
            
            for (int i = 0; i < 5; i++) {
                p = abs(p) - vec3(0.5, 0.8, 0.3);
                p.xy *= rot(0.5);
                boxFold(p, 1.0);
                sphereFold(p, 0.5, 1.0);
                p = p * scale - vec3(1.0, 2.0, 1.0);
            }
            
            return length(p) * pow(scale, -5.0);
        }

        // Fake Ambient Occlusion
        float calcAO(vec3 p, vec3 n) {
            float ao = 0.0;
            float sca = 1.0;
            for (int i = 0; i < 5; i++) {
                float hr = 0.01 + 0.12 * float(i) / 4.0;
                float d = map(p + n * hr);
                ao += (hr - d) * sca;
                sca *= 0.95;
            }
            return clamp(1.0 - 3.0 * ao, 0.0, 1.0);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_res) / min(u_res.x, u_res.y);
            vec2 m = (u_mouse / u_res) * 2.0 - 1.0;
            
            vec3 ro = vec3(0, 0, -4);
            vec3 rd = normalize(vec3(uv, 2.0));
            rd.xz *= rot(m.x * 0.3);
            rd.yz *= rot(-m.y * 0.3);
            
            float t = 0.0;
            float glow = 0.0;
            for (int i = 0; i < 128; i++) {
                float d = map(ro + rd * t);
                if (d < 0.0001 || t > 10.0) break;
                t += d;
                glow += 0.01 / (d + 0.02);
            }
            
            vec3 color = vec3(0.005, 0.01, 0.02);
            
            if (t < 10.0) {
                vec3 p = ro + rd * t;
                vec2 e = vec2(0.0001, 0);
                vec3 n = normalize(vec3(
                    map(p+e.xyy) - map(p-e.xyy),
                    map(p+e.yxy) - map(p-e.yxy),
                    map(p+e.yyx) - map(p-e.yyx)
                ));
                
                float ao = calcAO(p, n);
                float fresnel = pow(1.0 + dot(rd, n), 5.0);
                float diff = max(dot(n, normalize(vec3(1, 2, -3))), 0.0);
                
                color = vec3(0.1, 0.12, 0.15) * diff * ao;
                color += vec3(1.0, 0.0, 0.3) * fresnel * 0.5;
                color += vec3(0.0, 0.8, 1.0) * pow(glow * 0.05, 2.0);
            } else {
                // Background void
                color += vec3(0.1, 0.0, 0.2) * (1.0 - length(uv));
            }
            
            // Post: Bloom, Vignette, Grain
            float grain = fract(sin(dot(uv, vec2(12.9898, 78.233) + u_time)) * 43758.5453) * 0.05;
            color += grain;
            color *= 1.0 - length(uv) * 0.5;
            
            fragColor = vec4(pow(color, vec3(0.9)), 1.0);
        }
        `;

        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
            }
            return s;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);
        gl.useProgram(program);

        const uRes = gl.getUniformLocation(program, 'u_res');
        const uTime = gl.getUniformLocation(program, 'u_time');
        const uMouse = gl.getUniformLocation(program, 'u_mouse');

        let mx = 0, my = 0;
        window.addEventListener('mousemove', e => {
            mx = e.clientX;
            my = window.innerHeight - e.clientY;
        });

        function render(t) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uTime, t * 0.001);
            gl.uniform2f(uMouse, mx, my);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
