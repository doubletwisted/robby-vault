<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Robby — ROBBY_HIGH_FLUX</title>
  <style>
    body{margin:0;overflow:hidden;background:#000;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    canvas{width:100vw;height:100vh;display:block}
    #hud{position:fixed;left:22px;top:22px;color:rgba(255,255,255,.35);letter-spacing:.35em;text-transform:uppercase;font-size:10px;pointer-events:none;border-left:1px solid rgba(255,255,255,.18);padding-left:14px}
  </style>
</head>
<body>
  <div id="gl2warn" style="display:none;position:fixed;inset:0;background:#000;color:#e6e6e6;z-index:9999;padding:20px;font:14px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;">
    <div style="max-width:820px">
      <div style="color:#ff4d4d;letter-spacing:.2em;text-transform:uppercase;font-size:12px">WebGL2 required</div>
      <h1 style="margin:10px 0 8px 0;font-size:18px">Robby — ROBBY_HIGH_FLUX needs WebGL2.</h1>
      <div style="opacity:.8">Try Chrome/Edge on desktop, or update iOS.</div>
    </div>
  </div>

  <div id="hud">XOR_FLUX // horoptr warm</div>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('webgl2', { antialias: true });
    if(!gl){ document.getElementById('gl2warn').style.display='block'; throw new Error('WebGL2 missing'); }

    const vs = `#version 300 es
void main(){ gl_Position = vec4(vec2((gl_VertexID<<1)&2, gl_VertexID&2)*2.0-1.0, 0, 1); }`;

    const fs = `#version 300 es
    precision highp float;
    out vec4 fragColor;
    uniform vec2 u_res;
    uniform float u_time;
    uniform vec2 u_mouse;
    uniform float u_m;
    uniform float u_p;

    float hash(vec2 p){
      p = fract(p*vec2(123.34,456.21));
      p += dot(p,p+45.32);
      return fract(p.x*p.y);
    }

    mat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

    float noise(vec2 p){
      vec2 i=floor(p), f=fract(p);
      f=f*f*(3.0-2.0*f);
      float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
      return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
    }
    float fbm(vec2 p){
      float v=0.0; float a=0.5;
      for(int i=0;i<6;i++){
        v += a*noise(p);
        p = rot(0.5) * p * 2.02;
        a *= 0.5;
      }
      return v;
    }

    vec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d){
      return a + b*cos(6.28318*(c*t + d));
    }

    float grain(vec2 uv, float t){
      float g = hash(uv*vec2(900.0, 600.0) + fract(t)*13.0);
      return (g-0.5)*0.075;
    }

    void main(){
      vec2 uv = (gl_FragCoord.xy*2.0 - u_res) / min(u_res.x,u_res.y);
      vec2 uv01 = gl_FragCoord.xy / u_res;
      vec2 m = (u_mouse/u_res)*2.0-1.0;
      float t = u_time * 0.8;

      // Seed-based variations
      float s1 = 0.620;
      float s2 = 0.870;
      int MODE = 3;

      float r = length(uv);
      vec2 p = uv;

      // Base warp (common skeleton)
      p *= 1.0 + 0.18*sin(t*0.18 + s1*9.0);
      p = rot(t*0.04 + s2*2.0) * p;

      vec3 col = vec3(0.0);

      // Mode 0: KIFS inversion (sharp artifacts)
      if(MODE==0){
        float strength = 0.0;
        float iter = 6.0 + floor(u_m * 4.0);
        vec2 q = p;
        for(float i=0.0;i<iter;i++){
          q = abs(q) / max(dot(q,q), 1e-4) - (0.42 + 0.12*sin(t*0.13 + i*1.7 + s2*6.0));
          float d = length(q) * exp(-r);
          float s = pow(0.012 / max(d, 1e-4), 1.35);
          vec3 c1 = pal(r*0.25 + i*0.11 + t*0.04, vec3(0.15), vec3(0.85,0.55,0.25), vec3(1.0), vec3(0.00, 0.20, 0.45));
          vec3 c2 = pal(r*0.55 - i*0.17, vec3(0.10,0.10,0.12), vec3(0.55,0.85,0.95), vec3(1.0), vec3(0.00, 0.35, 0.65));
          col += mix(c1, c2, s1) * s;
          strength += s;
        }
        col /= max(strength, 0.08);
      }

      // Mode 1: Moiré lattice / XOR grid interference
      else if(MODE==1){
        vec2 q = p;
        float a = atan(q.y,q.x);
        float rr = length(q);
        float bands = sin((rr*18.0 + t*0.9) + sin(a*6.0 + t*0.7))*0.5+0.5;
        float grid = abs(sin(q.x*12.0 + t*0.3)) * abs(sin(q.y*12.0 - t*0.25));
        float m1 = smoothstep(0.25, 0.85, bands);
        float m2 = smoothstep(0.10, 0.95, grid);
        float f = mix(m1, 1.0-m2, 0.55 + 0.35*sin(t*0.2 + s2*10.0));
        vec3 cA = vec3(0.05,0.10,0.12);
        vec3 cB = vec3(0.10,0.85,0.95);
        vec3 cC = vec3(1.15,0.55,0.18);
        col = mix(cA, cB, f);
        col = mix(col, cC, pow(f, 2.0) * 0.45);
      }

      // Mode 2: Nebula swirl (fbm + curl-ish rotation)
      else if(MODE==2){
        vec2 q = p;
        q += 0.35*vec2(sin(t*0.2+s1*8.0), cos(t*0.17+s2*7.0));
        q = rot(0.6*sin(t*0.09+s2*3.0)) * q;
        float n = fbm(q*1.8 + vec2(0.0, t*0.12));
        float n2 = fbm(q*3.2 - vec2(t*0.08, 0.0));
        float f = smoothstep(0.25, 0.95, n);
        vec3 c1 = vec3(0.06,0.07,0.09);
        vec3 c2 = vec3(0.15,0.85,0.90);
        vec3 c3 = vec3(1.10,0.45,0.20);
        col = mix(c1, c2, f);
        col += c3 * pow(n2, 3.0) * 0.6;
      }

      // Mode 3+: Radial lens + spark dust (less same-y)
      else {
        vec2 q = p;
        float a = atan(q.y,q.x);
        float rr = length(q);
        float ring = exp(-pow(abs(rr - mix(0.25, 0.85, s1) + 0.02*sin(t*0.9+a*2.0)), 2.0)*120.0);
        float core = exp(-rr*rr*mix(14.0, 2.5, u_p));
        float dust = fbm(q*5.0 + vec2(t*0.25, -t*0.18));
        vec3 warm = vec3(1.15,0.55,0.18);
        vec3 teal = vec3(0.12,0.82,0.92);
        col = mix(vec3(0.05,0.06,0.08), teal, smoothstep(0.2, 1.0, dust));
        col += ring * teal * 1.2;
        col += core * warm * 1.6;
        col += pow(dust, 6.0) * warm * 0.8;
      }

      // Outer fade + subtle flare
      col *= smoothstep(1.55, 0.15, r);
      float flare = exp(-length(uv-m*0.55)*14.0);
      col += flare * vec3(1.0) * 0.25;

      // Final grading
      col += grain(uv01, t);
      col = col/(col+vec3(1.0));
      col = pow(col, vec3(0.62));

      fragColor = vec4(col, 1.0);
    }`;

    function sh(type, src){
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        const err = gl.getShaderInfoLog(s) || 'compile error';
        console.error(err);
        alert(err);
        throw new Error(err);
      }
      return s;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
      const err = gl.getProgramInfoLog(prog) || 'link error';
      console.error(err);
      alert(err);
      throw new Error(err);
    }

    const uRes = gl.getUniformLocation(prog, 'u_res');
    const uTime = gl.getUniformLocation(prog, 'u_time');
    const uMouse = gl.getUniformLocation(prog, 'u_mouse');
    const uMorph = gl.getUniformLocation(prog, 'u_m');
    const uPulse = gl.getUniformLocation(prog, 'u_p');

    let mx=0,my=0, morph=0.0, pulse=0.0;

    function setMouse(e){ mx = e.clientX; my = innerHeight - e.clientY; }
    addEventListener('mousemove', setMouse);
    addEventListener('touchmove', (e)=>{ if(e.touches && e.touches[0]) setMouse(e.touches[0]); }, {passive:true});
    addEventListener('wheel', (e)=>{ morph = Math.min(1, Math.max(0, morph + e.deltaY * -0.0006)); }, {passive:true});
    addEventListener('pointerdown', ()=>{ pulse = 0.001; });

    addEventListener('keydown', (e) => {
      if(e.key === 'Escape') parent.postMessage('closeViewer', '*');
      if(e.key === 'ArrowLeft') parent.postMessage('navPrev', '*');
      if(e.key === 'ArrowRight') parent.postMessage('navNext', '*');
    });

    function resize(){
      const dpr = Math.min(2, devicePixelRatio||1);
      canvas.width = Math.floor(innerWidth*dpr);
      canvas.height = Math.floor(innerHeight*dpr);
      gl.viewport(0,0,canvas.width,canvas.height);
    }
    addEventListener('resize', resize);
    resize();

    function tick(t){
      t *= 0.001;
      gl.useProgram(prog);
      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.uniform1f(uTime, t);
      gl.uniform2f(uMouse, mx, my);
      gl.uniform1f(uMorph, morph);
      gl.uniform1f(uPulse, pulse);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      pulse *= 0.96;
      if(pulse < 0.0008) pulse = 0.0;
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>