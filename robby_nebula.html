<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Neural Nebula - Robby Freestyle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Space Grotesk', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed;
            bottom: 40px;
            right: 40px;
            color: rgba(255, 0, 255, 0.4);
            letter-spacing: 0.6em;
            text-transform: uppercase;
            font-size: 7px;
            pointer-events: none;
            text-align: right;
            border-right: 1px solid rgba(255, 0, 255, 0.2);
            padding-right: 15px;
        }
    </style>
</head>
<body>
    <div id="gl2warn" style="display:none;position:fixed;inset:0;background:#000;color:#e6e6e6;z-index:9999;font:14px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;padding:20px">
      <div style="max-width:820px">
        <div style="color:#ff4d4d;letter-spacing:.2em;text-transform:uppercase;font-size:12px">WebGL2 required</div>
        <h1 style="margin:10px 0 8px 0;font-size:18px">This piece needs WebGL2.</h1>
        <div style="opacity:.8">If you're on iOS Safari or an older browser/device, it may not support WebGL2. Try Chrome/Edge on desktop, or update iOS.</div>
      </div>
    </div>
<div id="hud">
        Experiment 19 // Neural Nebula<br>
        Scattering: ANISOTROPIC<br>
        Density: 128-STEP
    </div>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2', { antialias: false });

        const vs = `#version 300 es
            void main() {
                gl_Position = vec4(vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) * 2.0 - 1.0, 0.0, 1.0);
            }
        `;

        const fs = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        uniform vec2 u_res;
        uniform float u_time;
        uniform vec2 u_mouse;

        mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }

        float hash(float n) { return fract(sin(n) * 43758.5453); }
        float noise(vec3 x) {
            vec3 p = floor(x); vec3 f = fract(x);
            f = f*f*(3.0-2.0*f);
            float n = p.x + p.y*57.0 + 113.0*p.z;
            return mix(mix(mix(hash(n+0.0),hash(n+1.0),f.x),mix(hash(n+57.0),hash(n+58.0),f.x),f.y),
                       mix(mix(hash(n+113.0),hash(n+114.0),f.x),mix(hash(n+170.0),hash(n+171.0),f.x),f.y),f.z);
        }

        float fbm(vec3 p) {
            float v = 0.0; float a = 0.5;
            for (int i = 0; i < 4; i++) { v += a * noise(p); p *= 2.02; a *= 0.5; }
            return v;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_res) / min(u_res.x, u_res.y);
            vec2 m = (u_mouse / u_res) * 2.0 - 1.0;
            
            vec3 ro = vec3(0, 0, -3);
            vec3 rd = normalize(vec3(uv, 1.5));
            rd.xz *= rot(m.x * 0.3);
            rd.yz *= rot(-m.y * 0.3);

            vec3 col = vec3(0.0);
            float t = 0.0;
            float dither = hash(uv.x + uv.y * 100.0 + u_time) * 0.1;
            t += dither;

            // Volumetric Raymarching
            for(int i=0; i<64; i++) {
                vec3 p = ro + rd * t;
                float d = fbm(p * 0.8 + u_time * 0.1);
                
                // Density accumulation
                float density = smoothstep(0.4, 0.7, d);
                if(density > 0.01) {
                    vec3 localCol = mix(vec3(0.1, 0.0, 0.4), vec3(1.0, 0.2, 0.5), density);
                    localCol += mix(vec3(0.0, 0.4, 1.0), vec3(0.0, 1.0, 0.8), p.y * 0.5 + 0.5) * 0.2;
                    col += localCol * density * 0.05;
                }
                
                t += 0.15;
                if(t > 8.0) break;
            }

            // Post-process: Soften and Gamma
            col *= 1.2;
            col = pow(col, vec3(0.85));
            col *= 1.0 - dot(uv, uv) * 0.5;

            fragColor = vec4(col, 1.0);
        }
        `;

        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                const err = gl.getShaderInfoLog(s) || 'Unknown shader compile error';
                console.error(err);
                alert('Shader compile failed:\n' + err);
                throw new Error(err);
            }
            return s;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);

        const uRes = gl.getUniformLocation(program, 'u_res');
        const uTime = gl.getUniformLocation(program, 'u_time');
        const uMouse = gl.getUniformLocation(program, 'u_mouse');

        let mx = 0, my = 0;
        window.addEventListener('mousemove', e => { mx = e.clientX; my = window.innerHeight - e.clientY; });
        window.addEventListener('touchmove', e => { mx = e.touches[0].clientX; my = window.innerHeight - e.touches[0].clientY; });

        function render(t) {
            const w = window.innerWidth, h = window.innerHeight;
            if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
            gl.viewport(0, 0, w, h);
            gl.useProgram(program);
            gl.uniform2f(uRes, w, h);
            gl.uniform1f(uTime, t * 0.001);
            gl.uniform2f(uMouse, mx, my);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
