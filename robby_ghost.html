<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Latent Ghost - Robby Freestyle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Space Grotesk', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed;
            bottom: 40px;
            right: 40px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.8em;
            text-transform: uppercase;
            font-size: 7px;
            pointer-events: none;
            text-align: right;
            border-right: 2px solid rgba(255, 255, 255, 0.3);
            padding-right: 20px;
        }
        #debug { position: fixed; top: 10px; left: 10px; color: #ff0; font-size: 9px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="hud">
        Experiment 15 // The Latent Ghost<br>
        Particle Density: 65,536<br>
        Compute: FRAGMENT-SIM
    </div>
    <div id="debug"></div>
    <canvas id="glCanvas"></canvas>
    <script>
        const debug = document.getElementById('debug');
        function log(msg) { debug.innerText += msg + '\n'; }
        window.onerror = (e) => log('Error: ' + e);

        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2', { antialias: false });

        if(!gl) log('WebGL2 not available');
        
        const extFloat = gl.getExtension('EXT_color_buffer_float');
        if(!extFloat) log('Float buffer extension MISSING');

        const vs = `#version 300 es
            void main() {
                gl_Position = vec4(vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) * 2.0 - 1.0, 0.0, 1.0);
            }
        `;

        const fsSim = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        uniform sampler2D u_pos;
        uniform vec2 u_res;
        uniform float u_time;
        uniform vec2 u_mouse;
        float hash(float n) { return fract(sin(n) * 43758.5453); }
        void main() {
            vec2 uv = gl_FragCoord.xy / u_res;
            vec4 data = texture(u_pos, uv);
            vec2 pos = data.xy;
            vec2 vel = data.zw;
            vec2 m = (u_mouse / u_res) * 2.0 - 1.0;
            vec2 dir = m - pos;
            float dist = length(dir);
            vel += normalize(dir) * 0.002 * (1.0 / (dist + 0.2));
            float angle = sin(pos.x * 5.0 + u_time) * cos(pos.y * 5.0 + u_time);
            vel += vec2(cos(angle), sin(angle)) * 0.0008;
            vel *= 0.97;
            pos += vel;
            if (abs(pos.x) > 1.1 || abs(pos.y) > 1.1) {
                pos = vec2(hash(uv.x + u_time) * 2.0 - 1.0, hash(uv.y + u_time) * 2.0 - 1.0);
                vel = vec2(0.0);
            }
            fragColor = vec4(pos, vel);
        }
        `;

        const vsRender = `#version 300 es
        uniform sampler2D u_pos;
        out float v_vel;
        void main() {
            int x = gl_InstanceID % 256;
            int y = gl_InstanceID / 256;
            vec4 data = texelFetch(u_pos, ivec2(x, y), 0);
            v_vel = length(data.zw);
            gl_Position = vec4(data.xy, 0.0, 1.0);
            gl_PointSize = 1.0 + v_vel * 150.0;
        }
        `;

        const fsRender = `#version 300 es
        precision highp float;
        in float v_vel;
        out vec4 fragColor;
        void main() {
            float d = length(gl_PointCoord - 0.5);
            if (d > 0.5) discard;
            vec3 col = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.9, 0.8), v_vel * 30.0);
            fragColor = vec4(col, (0.5 - d) * 1.5);
        }
        `;

        function createShader(gl, type, source) {
            const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) log('Shader err: ' + gl.getShaderInfoLog(s));
            return s;
        }

        function createProgram(gl, vsS, fsS) {
            const p = gl.createProgram();
            gl.attachShader(p, createShader(gl, gl.VERTEX_SHADER, vsS));
            gl.attachShader(p, createShader(gl, gl.FRAGMENT_SHADER, fsS));
            gl.linkProgram(p);
            if(!gl.getProgramParameter(p, gl.LINK_STATUS)) log('Link err: ' + gl.getProgramInfoLog(p));
            return p;
        }

        const simProg = createProgram(gl, vs, fsSim);
        const renderProg = createProgram(gl, vsRender, fsRender);

        const simSize = 256;
        const textures = [gl.createTexture(), gl.createTexture()];
        const fbos = [gl.createFramebuffer(), gl.createFramebuffer()];

        function initSimFBO(idx) {
            gl.bindTexture(gl.TEXTURE_2D, textures[idx]);
            const data = new Float32Array(simSize * simSize * 4);
            for(let i=0; i<data.length; i+=4) {
                data[i] = Math.random() * 2 - 1;
                data[i+1] = Math.random() * 2 - 1;
            }
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, simSize, simSize, 0, gl.RGBA, gl.FLOAT, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[idx]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[idx], 0);
            if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) log('FBO SIM ERR');
        }

        initSimFBO(0); initSimFBO(1);

        let current = 0, mx = 0, my = 0;
        window.addEventListener('mousemove', e => { mx = e.clientX; my = window.innerHeight - e.clientY; });
        window.addEventListener('touchmove', e => { mx = e.touches[0].clientX; my = window.innerHeight - e.touches[0].clientY; });

        function render(t) {
            gl.viewport(0, 0, simSize, simSize);
            gl.useProgram(simProg);
            gl.uniform2f(gl.getUniformLocation(simProg, 'u_res'), simSize, simSize);
            gl.uniform1f(gl.getUniformLocation(simProg, 'u_time'), t * 0.001);
            gl.uniform2f(gl.getUniformLocation(simProg, 'u_mouse'), mx, my);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[1 - current]);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[current]);
            gl.drawArrays(gl.TRIANGLES, 0, 3);

            const w = window.innerWidth, h = window.innerHeight;
            if(canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
            gl.viewport(0, 0, w, h);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.useProgram(renderProg);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[current]);
            gl.drawArraysInstanced(gl.POINTS, 0, 1, simSize * simSize);
            gl.disable(gl.BLEND);

            current = 1 - current;
            requestAnimationFrame(render);
        }
        log('Ghost init...');
        requestAnimationFrame(render);
    </script>
</body>
</html>
