<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Fabric - Robby Freestyle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300&display=swap');
        body { margin: 0; overflow: hidden; background: #010205; font-family: 'Space Grotesk', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed;
            top: 50px;
            left: 50px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 0.8em;
            text-transform: uppercase;
            font-size: 7px;
            pointer-events: none;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding-left: 20px;
            mix-blend-mode: difference;
        }
    </style>
</head>
<body>
    <div id="hud">
        Experiment 12 // Neural Fabric<br>
        Domain: Latent Materiality<br>
        Substrate: Conductive Silk
    </div>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2', { antialias: true });

        const vs = `#version 300 es
            void main() {
                gl_Position = vec4(vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) * 2.0 - 1.0, 0.0, 1.0);
            }
        `;

        const fs = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        uniform vec2 u_res;
        uniform float u_time;
        uniform vec2 u_mouse;

        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        float hash(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        // Domain Warped FBM for "Fabric" Texture
        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            vec2 shift = vec2(100);
            for (int i = 0; i < 8; ++i) {
                v += a * noise(p);
                p = rot(0.5) * p * 2.0 + shift;
                a *= 0.55;
            }
            return v;
        }

        // Palette inspired by high-end motion design
        vec3 palette(float t) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.3, 0.2, 0.2);
            return a + b * cos(6.28318 * (c * t + d));
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_res) / min(u_res.x, u_res.y);
            vec2 m = (u_mouse / u_res) * 2.0 - 1.0;
            
            // Domain Warping Logic (Anadol/Quilez style)
            vec2 q = vec2(0.0);
            q.x = fbm(uv + 0.1 * u_time);
            q.y = fbm(uv + vec2(1.0));

            vec2 r = vec2(0.0);
            r.x = fbm(uv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);
            r.y = fbm(uv + 1.0 * q + vec2(8.3, 2.8) + 0.126 * u_time);

            float f = fbm(uv + r);
            
            // Light and Shadow (Pseudo-Normal Mapping)
            float e = 0.01;
            float f_x = fbm(uv + r + vec2(e, 0.0));
            float f_y = fbm(uv + r + vec2(0.0, e));
            vec3 n = normalize(vec3(f - f_x, f - f_y, e));
            
            // Interaction: Mouse as a soft light source
            vec3 l = normalize(vec3(m.x, -m.y, 1.0));
            float diff = max(dot(n, l), 0.0);
            float spec = pow(max(dot(reflect(-l, n), vec3(0,0,-1)), 0.0), 32.0);
            
            // Coloring
            vec3 color = vec3(0.02, 0.03, 0.06); // Deep base
            color = mix(color, vec3(0.05, 0.1, 0.2), f);
            color = mix(color, vec3(0.1, 0.2, 0.4), dot(q, q));
            color = mix(color, palette(f + u_time * 0.05), r.y * 0.5);
            
            // Specular and Highlight
            color += diff * vec3(0.0, 0.4, 0.6) * 0.3;
            color += spec * vec3(1.0, 1.0, 1.0) * 0.4;
            
            // Subtle "Silk" sheen
            float sheen = pow(1.0 - abs(dot(n, vec3(0,0,1))), 2.0);
            color += sheen * vec3(0.4, 0.7, 1.0) * 0.1;
            
            // Technical Artifacts
            float noiseGrain = hash(uv + u_time) * 0.02;
            color += noiseGrain;
            
            // Vignette
            color *= smoothstep(1.5, 0.6, length(uv));
            
            fragColor = vec4(pow(color, vec3(1.1)), 1.0);
        }
        </script>
</body>
</html>
