<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Latent Space - Robby Freestyle</title>
    <style>
        body { margin: 0; overflow: hidden; background: #05070c; font-family: 'Space Grotesk', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(231, 240, 255, 0.4);
            letter-spacing: 0.2em;
            text-transform: uppercase;
            font-size: 10px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gl2warn" style="display:none;position:fixed;inset:0;background:#000;color:#e6e6e6;z-index:9999;font:14px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;padding:20px">
      <div style="max-width:820px">
        <div style="color:#ff4d4d;letter-spacing:.2em;text-transform:uppercase;font-size:12px">WebGL2 required</div>
        <h1 style="margin:10px 0 8px 0;font-size:18px">This piece needs WebGL2.</h1>
        <div style="opacity:.8">If you're on iOS Safari or an older browser/device, it may not support WebGL2. Try Chrome/Edge on desktop, or update iOS.</div>
      </div>
    </div>
<div id="hud">Latent Space Signal // Robby_HiveMind</div>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) {
            const w = document.getElementById('gl2warn');
            if (w) w.style.display = 'block';
            throw new Error('WebGL2 not available');
        }

        const vs = `#version 300 es
            void main() {
                gl_Position = vec4(vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) * 2.0 - 1.0, 0.0, 1.0);
            }
        `;

        const fs = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        uniform vec2 u_res;
        uniform float u_time;
        uniform vec2 u_mouse;

        float hash(vec2 p) {
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 45.32);
            return fract(p.x * p.y);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i = 0; i < 6; i++) {
                v += a * noise(p);
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_res) / min(u_res.x, u_res.y);
            vec2 m = (u_mouse * 2.0 - u_res) / min(u_res.x, u_res.y);
            
            vec2 q = vec2(fbm(uv + u_time * 0.1), fbm(uv + vec2(5.2, 1.3)));
            vec2 r = vec2(fbm(uv + 4.0 * q + vec2(1.7, 9.2) + u_time * 0.15), fbm(uv + 4.0 * q + vec2(8.3, 2.8) + u_time * 0.126));
            float f = fbm(uv + 4.0 * r);
            
            float dist = length(uv - m * 0.5);
            float glow = 0.02 / (dist + 0.01);
            
            vec3 color = mix(vec3(0.01, 0.02, 0.05), vec3(0.05, 0.0, 0.1), f);
            color = mix(color, vec3(0.0, 0.3, 0.6), dot(q, q));
            color = mix(color, vec3(0.6, 0.1, 0.4), r.y);
            
            float scanline = sin(gl_FragCoord.y * 0.8 + u_time * 15.0) * 0.015;
            color += scanline * f;
            
            color *= f * f * f * 3.0 + 0.3 * f;
            color += glow * vec3(0.3, 0.6, 1.0) * f;
            
            fragColor = vec4(pow(color, vec3(0.9)), 1.0);
        }
        `;

        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                const err = gl.getShaderInfoLog(s) || 'Unknown shader compile error';
                console.error(err);
                alert('Shader compile failed:\n' + err);
                throw new Error(err);
            }
            return s;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const err = gl.getProgramInfoLog(program) || 'Unknown program link error';
            console.error(err);
            alert('Program link failed:\n' + err);
            throw new Error(err);
        }
        gl.useProgram(program);

        const uRes = gl.getUniformLocation(program, 'u_res');
        const uTime = gl.getUniformLocation(program, 'u_time');
        const uMouse = gl.getUniformLocation(program, 'u_mouse');

        let mx = 0, my = 0;
        window.addEventListener('mousemove', e => {
            mx = e.clientX;
            my = window.innerHeight - e.clientY;
        });

        function render(t) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uTime, t * 0.001);
            gl.uniform2f(uMouse, mx, my);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
